from __future__ import annotations
from abc import ABC, abstractmethod
import io
import sys
import traceback
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

from dosaku import Task, task_hub, module_manager, ExecutorPermissionRequired, InterpreterError
from dosaku.utils import ifnone


class Module(ABC):
    @property
    @abstractmethod
    def name(self) -> str:
        raise NotImplementedError

    @property
    def is_service(self) -> bool:
        return False

    @property
    def is_executor(self) -> bool:
        return False

    @classmethod
    def exec(
            cls,
            code: str,
            globals: Dict[str, Any] = None,
            locals: Dict[str, Any] = None,
            description: str = 'source code'
    ) -> Tuple[str, str]:
        """Runs the given python code.

        Wrapper around Python's exec to run a dynamically created program. It is expected that this code is being
        dynamically generated by an AI agent, and that it is not yet known if this code will run without errors or bugs.

        By default, *globals['__builtins__']* will be set to an empty dict. Doing so makes it impossible to run any
        python builtin methods, such as *__import__* (i.e. import). This design choice is meant as a safety measure
        against (accidentally) doing something like the following::

            from dosaku.agents import Dosaku

            dosk = Dosaku(enable_services=True, enable_executors=True, stream_chat=False)
            dosk.learn('Tester')

            code = dosk.Chat('Write some python code that should never be run.')  # import os; os.system('rm -rf *')
            dosk.Tester.exec(code)  # will try to delete every file on disk

        The default behavior makes the above code throw an error back to the user::

            ImportError at line 1 of source code: __import__ not found

        To override this default behavior, pass in any desired globals explicitly (both variables and builtins). Refer
        to the `python docs <https://docs.python.org/3/library/functions.html>`_ to see a complete list of python
        builtins. To pass in an explicit set, you may do something similar to::

            code = dosk.Chat(
                'Write a method that generates two random integers and prints the smaller one. Test the method.')

            print(code)
                \"\"\"
                import random
                def print_smaller():
                    a = random.randint(1, 100)
                    b = random.randint(1, 100)
                    print(min(a, b))
                print_smaller()
                \"\"\"

            Executor.exec(code)  # ImportError at line 1 of source code: __import__ not found

            allowed_builtins = {'__import__': __import__, 'print': print, 'min': min}
            Executor.exec(code, globals = {'__builtins__': allowed_builtins})  # 55

        Args:
            code: The python code to run.
            globals: The globals to pass to exec.
            locals: The locals to pass to exec.
            description: Description of the code being executed. Will appear in any returned exception.

        Returns:
            A tuple of the form (code output, any errors generated).

        Example for default usage (e.g. here nothing is returned, it just tests if an exception is thrown)::

            from dosaku.agents import Dosaku

            dosk = Dosaku(enable_services=True, enable_executors=True, stream_chat=False)
            dosk.learn('Tester')

            code = dosk.Chat(
                'Write a python method, gcd, that computes the greatest common denominator between two integers. '
                'Assert the gcd of 21600 and 5040 is 740.')
            print(code)
                \"\"\"
                def gcd(a, b):
                    while b != 0:
                        a, b = b, a % b
                    return a
                assert gcd(21600, 5040) == 740
                \"\"\"
            results, err = dosk.Tester.exec(code)  # '', ''

        Example explicitly setting builtins::

            from dosaku.agents import Dosaku

            dosk = Dosaku(enable_services=True, enable_executors=True, stream_chat=False)
            dosk.learn('Tester')

            code = dosk.Chat(
                'Write a python method, gen_grade, to generate a random numerical grade given a string input, '
                '"A", "B", "C", "D", or "F". Use the method to print 2 random As, 3 random Bs and 2 random Cs.')
            allowed_builtins = {'__import__': __import__, 'range': range, 'print': print}
            results, err = dosk.Tester.exec(code, globals=dict('__builtins__': allowed_builtins))
            print(results)  # 96 100 85 87 86 75 72

            gen_grade('B')  # NameError: name 'gen_grade' is not defined

        Example capturing the exec locals into the current globals::

            from dosaku.agents import Dosaku

            dosk = Dosaku(enable_services=True, enable_executors=True, stream_chat=False)
            dosk.learn('Tester')

            code = dosk.Chat(
                'Write a python method, gen_grade, to generate a random numerical grade given a string input, '
                '"A", "B", "C", "D", or "F".')
            dosk.Tester.exec(
                code,
                globals=globals(),
                locals=globals()
            )

            gen_grade('B')  # 82

        .. warning::
            Do not run any code you do not trust. Do not allow executors to run code on your behalf that you do not
            trust. You are ultimately responsible for whatever code is run on your behalf, regardless of its
            output or consequences.

        """
        if cls.is_executor:
            globals = ifnone(globals, default={"__builtins__": {}})

            # create file-like string to capture output
            codeOut = io.StringIO()
            codeErr = io.StringIO()

            # capture output and errors
            sys.stdout = codeOut
            sys.stderr = codeErr

            error_message = lambda error_class, line_number, description, detail: \
                f'{error_class} at line {line_number} of {description}: {detail}'

            try:
                exec(code, globals, locals)

            except SyntaxError as err:
                error_class = err.__class__.__name__
                detail = err.args[0]
                line_number = err.lineno
                codeErr.write(error_message(error_class, line_number, description, detail))

            except Exception as err:
                error_class = err.__class__.__name__
                detail = err.args[0]
                cl, exc, tb = sys.exc_info()
                line_number = traceback.extract_tb(tb)[-1][1]
                codeErr.write(error_message(error_class, line_number, description, detail))

            finally:
                # restore stdout and stderr
                sys.stdout = sys.__stdout__
                sys.stderr = sys.__stderr__

            return codeOut.getvalue(), codeErr.getvalue()

        else:
            raise ExecutorPermissionRequired(
                f'Module {cls.name} is not an executor, but tried to run exec. Only executors are allowed to run exec.')

    @classmethod
    def api(cls) -> Optional[Dict[str, str]]:
        return getattr(cls, 'api_task_actions', None)

    @classmethod
    def docs(cls) -> Dict[str, str]:
        doc = {cls.name: cls.__doc__}
        for attr in cls.api():
            doc[attr] = getattr(cls, attr).__doc__
        return doc

    @classmethod
    def register_action(cls, func: Union[str, Callable], doc: Optional[str] = None):
        if getattr(cls, 'api_task_actions', None) is None:
            cls.api_task_actions: Dict[str, str] = dict()

        if isinstance(func, Callable):
            func = func.__name__
            if doc is None:
                doc = func.__doc__
        cls.api_task_actions[func] = doc

    @classmethod
    def register_dependency(cls, dependency: Union[str, Module]):
        if isinstance(dependency, Module):
            dependency = dependency.name
        if getattr(cls, '_dependencies', None) is None:
            cls._dependencies: List[str] = list()
        cls._dependencies.append(dependency)

    @classmethod
    @property
    def dependencies(cls):
        return getattr(cls, '_dependencies', list())

    @classmethod
    def register_module(cls):
        module_manager.register_builder(module=cls.name, builder=cls, dependencies=getattr(cls, '_dependencies', list()))

    @classmethod
    def register_task(cls, task: str):
        cls.register_module()
        if task == cls.__name__:  # Module is acting as both Task & Module. Register a new task derived from the Module.
            new_task = Task.create(name=task, api=cls.api())
            task_hub.register_task(task=new_task.name, api=new_task.api(), docs=new_task.docs())
        task_hub.register_module(cls, tasks=task)
